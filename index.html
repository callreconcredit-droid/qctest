<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Excel Uploader & Editor • GitHub Pages</title>
  <meta name="description" content="Upload, edit, fill, and save Excel/CSV files back to GitHub using the Contents API. Single-file app for GitHub Pages." />
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- SheetJS for reading/writing Excel files in the browser -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    .kbd{border:1px solid #e5e7eb;border-bottom-width:3px;border-radius:.375rem;padding:.125rem .375rem;font-size:.75rem}
    /* Top-center toast */
    #toast{position:fixed;top:1rem;left:50%;transform:translateX(-50%);
      background:#111827;color:white;padding:12px 16px;border-radius:12px;box-shadow:0 10px 20px rgba(0,0,0,.15);
      opacity:0;pointer-events:none;transition:opacity .2s, transform .2s;z-index:50}
    #toast.show{opacity:1;pointer-events:auto;transform:translateX(-50%) translateY(0)}
    table { border-collapse: collapse; } 
    td, th { border: 1px solid #e5e7eb; padding: 6px 8px; }
    td[contenteditable="true"]:focus { outline: 2px solid #60a5fa; background: #eff6ff; }
    .scroll-wrap{overflow:auto; max-height: 60vh}
  </style>
</head>
<body class="bg-gray-50 min-h-screen">
  <!-- Toast -->
  <div id="toast"></div>

  <div class="max-w-7xl mx-auto p-6">
    <header class="flex flex-col gap-2 sm:flex-row sm:items-end sm:justify-between mb-4">
      <div>
        <h1 class="text-2xl sm:text-3xl font-bold text-gray-800">Excel Uploader & Editor</h1>
        <p class="text-gray-500">Upload a .xlsx or .csv, edit in the browser, auto-fill blanks, then save back to GitHub.</p>
      </div>
      <div class="flex flex-wrap gap-2">
        <label class="inline-flex items-center gap-2 text-sm bg-white border rounded-xl px-3 py-2 shadow-sm">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 4h16v16H4z"/><path d="M8 4v16M16 4v16M4 8h16M4 16h16"/></svg>
          <input id="fileInput" type="file" accept=".xlsx,.xls,.csv" class="hidden" />
          <span class="font-medium">Choose file</span>
        </label>
        <button id="downloadCsv" class="text-sm bg-white border rounded-xl px-3 py-2 shadow-sm">Download CSV</button>
        <button id="downloadXlsx" class="text-sm bg-white border rounded-xl px-3 py-2 shadow-sm">Download XLSX</button>
      </div>
    </header>

    <!-- GitHub Settings -->
    <section class="bg-white rounded-2xl shadow p-4 mb-4">
      <div class="flex flex-wrap items-end gap-3">
        <div>
          <label class="block text-xs text-gray-500">Owner / Org</label>
          <input id="ghOwner" class="border rounded-lg px-3 py-2 w-48" placeholder="your-username-or-org" />
        </div>
        <div>
          <label class="block text-xs text-gray-500">Repository</label>
          <input id="ghRepo" class="border rounded-lg px-3 py-2 w-48" placeholder="your-repo" />
        </div>
        <div>
          <label class="block text-xs text-gray-500">Branch</label>
          <input id="ghBranch" class="border rounded-lg px-3 py-2 w-36" value="main" />
        </div>
        <div class="flex-1 min-w-[240px]">
          <label class="block text-xs text-gray-500">Path in repo (e.g. data/sheet.xlsx or data/sheet.csv)</label>
          <input id="ghPath" class="border rounded-lg px-3 py-2 w-full" placeholder="data/myfile.xlsx" />
        </div>
        <div class="flex-1 min-w-[240px]">
          <label class="block text-xs text-gray-500">GitHub Fine-grained PAT (repo contents: read & write)</label>
          <input id="ghToken" type="password" class="border rounded-lg px-3 py-2 w-full" placeholder="ghp_..." autocomplete="off" />
        </div>
      </div>
      <div class="flex flex-wrap gap-2 mt-3">
        <button id="btnConnect" class="bg-indigo-600 text-white rounded-xl px-4 py-2">Connect</button>
        <button id="btnSaveCsv" class="bg-emerald-600 text-white rounded-xl px-4 py-2">Save as CSV</button>
        <button id="btnSaveXlsx" class="bg-emerald-700 text-white rounded-xl px-4 py-2">Save as XLSX</button>
        <span class="text-xs text-gray-500">Commits use the GitHub Contents API. Your token is kept in-memory only.</span>
      </div>
    </section>

    <!-- Tools -->
    <section class="bg-white rounded-2xl shadow p-4 mb-4">
      <div class="flex flex-wrap gap-2">
        <button id="btnFillDown" class="bg-gray-100 rounded-xl px-3 py-2">Fill down blanks (per column)</button>
        <button id="btnFillZero" class="bg-gray-100 rounded-xl px-3 py-2">Replace empty numeric cells with 0</button>
        <button id="btnTrim" class="bg-gray-100 rounded-xl px-3 py-2">Trim whitespace</button>
        <button id="btnAddRow" class="bg-gray-100 rounded-xl px-3 py-2">Add row</button>
        <button id="btnAddCol" class="bg-gray-100 rounded-xl px-3 py-2">Add column</button>
        <button id="btnValidate" class="bg-gray-100 rounded-xl px-3 py-2">Validate (report blanks)</button>
      </div>
    </section>

    <!-- Grid -->
    <section class="bg-white rounded-2xl shadow p-4">
      <div id="sheetMeta" class="text-sm text-gray-500 mb-2">No file loaded.</div>
      <div class="scroll-wrap border rounded-xl">
        <table id="grid" class="w-full text-sm"></table>
      </div>
    </section>

    <footer class="text-xs text-gray-400 mt-6">
      <p>Tip: Keep large files as CSV for smaller commits & readable diffs. XLSX works too via SheetJS.</p>
    </footer>
  </div>

<script>
  // ---------- Utilities ----------
  const $ = sel => document.querySelector(sel);
  const toast = (msg, type="info") => {
    const t = $('#toast');
    t.textContent = msg;
    t.style.background = type === 'error' ? '#991b1b' : (type==='success'?'#065f46':'#111827');
    t.classList.add('show');
    setTimeout(() => t.classList.remove('show'), 2200);
  };

  const gridEl = $('#grid');
  let data = [[]]; // 2D array
  let header = []; // optional header row
  let hasHeader = true; // assume first row is header if detected from file
  let fileName = '';

  function renderTable(){
    gridEl.innerHTML = '';
    if(!data || data.length === 0){ gridEl.innerHTML = '<tr><td class="p-3 text-gray-400">No data</td></tr>'; return; }
    const thead = document.createElement('thead');
    const tbody = document.createElement('tbody');

    // Build header (A, B, C...) if no header available
    const cols = Math.max(...data.map(r => r.length));
    const defaultHdr = Array.from({length: cols}, (_,i)=> XLSX.utils.encode_col(i));
    const hdrRow = document.createElement('tr');
    const hdrCells = (hasHeader && data[0]) ? data[0].map((v,i)=> v===''? defaultHdr[i]: v) : defaultHdr;
    hdrCells.forEach((h,i)=>{
      const th = document.createElement('th');
      th.className='bg-gray-50 sticky top-0 z-10';
      th.textContent = h ?? '';
      th.contentEditable = hasHeader; // allow renaming header if present
      th.addEventListener('input', ()=>{ if(hasHeader) data[0][i] = th.textContent; });
      hdrRow.appendChild(th);
    });
    thead.appendChild(hdrRow);

    const startRow = hasHeader ? 1 : 0;
    for(let r = startRow; r < data.length; r++){
      const tr = document.createElement('tr');
      for(let c = 0; c < cols; c++){
        const td = document.createElement('td');
        td.contentEditable = true;
        td.textContent = (data[r] && data[r][c] !== undefined) ? data[r][c] : '';
        td.addEventListener('input', () => { ensureSize(r, c); data[r][c] = td.textContent; });
        tr.appendChild(td);
      }
      tbody.appendChild(tr);
    }

    gridEl.appendChild(thead);
    gridEl.appendChild(tbody);
    $('#sheetMeta').textContent = `${fileName || 'Untitled'} • ${data.length} rows x ${cols} cols`;
  }

  function ensureSize(r,c){
    while(data.length <= r) data.push([]);
    if(!data[r]) data[r] = [];
    while(data[r].length <= c) data[r].push('');
  }

  function fillDown(){
    const startRow = hasHeader ? 1 : 0;
    const cols = Math.max(...data.map(r => r.length));
    for(let c=0;c<cols;c++){
      let last = '';
      for(let r=startRow;r<data.length;r++){
        if(!data[r]) data[r] = [];
        if(data[r][c] === undefined) data[r][c] = '';
        if(data[r][c] === '' && last !== '') data[r][c] = last;
        if(data[r][c] !== '') last = data[r][c];
      }
    }
  }

  function fillZero(){
    const startRow = hasHeader ? 1 : 0;
    const cols = Math.max(...data.map(r => r.length));
    for(let r=startRow;r<data.length;r++){
      for(let c=0;c<cols;c++){
        const v = data[r][c];
        if(v === '') data[r][c] = '0';
      }
    }
  }

  function trimAll(){
    for(let r=0;r<data.length;r++){
      for(let c=0;c<(data[r]?.length||0);c++){
        const v = data[r][c];
        if(typeof v === 'string') data[r][c] = v.trim();
      }
    }
  }

  function addRow(){
    const cols = Math.max(...data.map(r => r.length));
    data.push(Array.from({length: cols}, ()=>''));
  }

  function addCol(){
    const cols = Math.max(...data.map(r => r.length)) + 1;
    data = data.map((r,i)=>{ const row = r? [...r] : []; while(row.length<cols) row.push(''); return row; });
    if(hasHeader){ data[0][cols-1] = `Col${cols}`; }
  }

  function validate(){
    const startRow = hasHeader ? 1 : 0;
    let blanks = 0;
    for(let r=startRow;r<data.length;r++){
      for(let c=0;c<(data[r]?.length||0);c++){
        if((data[r][c]??'') === '') blanks++;
      }
    }
    toast(`${blanks} blank cells found (excluding header)`, blanks? 'info':'success');
  }

  // ---------- Load file ----------
  $('#fileInput').addEventListener('change', async (e)=>{
    const file = e.target.files[0]; if(!file) return;
    fileName = file.name;
    const ext = file.name.split('.').pop().toLowerCase();
    const buffer = await file.arrayBuffer();
    if(ext === 'csv'){
      const text = new TextDecoder().decode(new Uint8Array(buffer));
      const rows = text.split(/\r?\n/).map(line=> line.split(','));
      // detect header if first row is non-numeric and subsequent rows are numeric-ish
      hasHeader = rows.length>1 && rows[0].some(v=>isNaN(Number(v))) ? true : true;
      data = rows;
      renderTable();
      toast('CSV loaded', 'success');
    } else {
      const wb = XLSX.read(buffer, {type:'array'});
      const sheet = wb.Sheets[wb.SheetNames[0]];
      const aoa = XLSX.utils.sheet_to_json(sheet, {header:1, raw:false});
      hasHeader = aoa.length>1 && aoa[0].some(v=>v!=='' );
      data = aoa;
      renderTable();
      toast('Excel loaded', 'success');
    }
  });

  // ---------- Download ----------
  $('#downloadCsv').addEventListener('click', ()=>{
    const startRow = 0; // keep header row as-is
    const csv = data.map(row => row.map(v => typeof v === 'string' && v.includes(',') ? `"${v.replace(/"/g,'""')}"` : (v??'')).join(',')).join('\n');
    const blob = new Blob([csv], {type: 'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = (fileName?.replace(/\.(xlsx|xls)$/i,'') || 'sheet') + '.csv';
    a.click();
  });

  $('#downloadXlsx').addEventListener('click', ()=>{
    const ws = XLSX.utils.aoa_to_sheet(data);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Sheet1');
    XLSX.writeFile(wb, (fileName || 'sheet') + (fileName.endsWith('.xlsx')? '' : '.xlsx'));
  });

  // ---------- Tools ----------
  $('#btnFillDown').addEventListener('click', ()=>{ fillDown(); renderTable(); toast('Fill-down applied','success'); });
  $('#btnFillZero').addEventListener('click', ()=>{ fillZero(); renderTable(); toast('Empty numeric cells → 0','success'); });
  $('#btnTrim').addEventListener('click', ()=>{ trimAll(); renderTable(); toast('Whitespace trimmed','success'); });
  $('#btnAddRow').addEventListener('click', ()=>{ addRow(); renderTable(); });
  $('#btnAddCol').addEventListener('click', ()=>{ addCol(); renderTable(); });
  $('#btnValidate').addEventListener('click', ()=> validate());

  // ---------- GitHub API helpers ----------
  const gh = {
    owner: '', repo: '', branch: 'main', path: '', token: '',
    async getFile(){
      const url = `https://api.github.com/repos/${this.owner}/${this.repo}/contents/${encodeURIComponent(this.path)}?ref=${this.branch}`;
      const res = await fetch(url, { headers: { Authorization: `Bearer ${this.token}`, 'Accept': 'application/vnd.github+json' } });
      if(res.status === 404) return { sha: null };
      if(!res.ok) throw new Error(`GitHub GET failed: ${res.status} ${await res.text()}`);
      const j = await res.json();
      return { sha: j.sha };
    },
    async putFile(contentB64, message){
      const url = `https://api.github.com/repos/${this.owner}/${this.repo}/contents/${encodeURIComponent(this.path)}`;
      const current = await this.getFile();
      const body = { message, content: contentB64, branch: this.branch };
      if(current.sha) body.sha = current.sha;
      const res = await fetch(url, { method:'PUT', headers: { Authorization: `Bearer ${this.token}`, 'Accept': 'application/vnd.github+json' }, body: JSON.stringify(body) });
      if(!res.ok) throw new Error(`GitHub PUT failed: ${res.status} ${await res.text()}`);
      return res.json();
    },
    async connect(){
      try{
        const url = `https://api.github.com/repos/${this.owner}/${this.repo}`;
        const res = await fetch(url, { headers: { Authorization: `Bearer ${this.token}`, 'Accept': 'application/vnd.github+json' } });
        if(!res.ok) throw new Error(`Connect failed: ${res.status}`);
        const j = await res.json();
        toast(`Connected to ${j.full_name}`, 'success');
      }catch(e){ toast(e.message, 'error'); }
    }
  };

  function refreshGhFromInputs(){
    gh.owner = $('#ghOwner').value.trim();
    gh.repo = $('#ghRepo').value.trim();
    gh.branch = $('#ghBranch').value.trim() || 'main';
    gh.path = $('#ghPath').value.trim();
    gh.token = $('#ghToken').value.trim();
  }

  $('#btnConnect').addEventListener('click', ()=>{ refreshGhFromInputs(); gh.connect(); });

  async function saveAsCsv(){
    refreshGhFromInputs();
    if(!gh.owner || !gh.repo || !gh.path || !gh.token) return toast('Owner, repo, path, token required', 'error');
    try{
      const csv = data.map(row => row.map(v => typeof v === 'string' && v.includes(',') ? `"${v.replace(/"/g,'""')}"` : (v??'')).join(',')).join('\n');
      const b64 = btoa(unescape(encodeURIComponent(csv)));
      await gh.putFile(b64, `Update ${gh.path} via web editor`);
      toast('Saved CSV to GitHub','success');
    }catch(e){ toast(e.message, 'error'); }
  }

  async function saveAsXlsx(){
    refreshGhFromInputs();
    if(!gh.owner || !gh.repo || !gh.path || !gh.token) return toast('Owner, repo, path, token required', 'error');
    try{
      const ws = XLSX.utils.aoa_to_sheet(data);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, 'Sheet1');
      const wbout = XLSX.write(wb, {type:'array', bookType:'xlsx'});
      // Convert to Base64
      const b64 = arrayBufferToBase64(wbout);
      await gh.putFile(b64, `Update ${gh.path} via web editor (xlsx)`);
      toast('Saved XLSX to GitHub','success');
    }catch(e){ toast(e.message, 'error'); }
  }

  function arrayBufferToBase64(buffer){
    let binary = '';
    const bytes = new Uint8Array(buffer);
    const chunk = 0x8000;
    for(let i = 0; i < bytes.length; i += chunk){
      const sub = bytes.subarray(i, i + chunk);
      binary += String.fromCharCode.apply(null, sub);
    }
    return btoa(binary);
  }

  $('#btnSaveCsv').addEventListener('click', saveAsCsv);
  $('#btnSaveXlsx').addEventListener('click', saveAsXlsx);

  // Prefill from query string (optional): ?owner=&repo=&branch=&path=
  const qs = new URLSearchParams(location.search);
  if(qs.get('owner')) $('#ghOwner').value = qs.get('owner');
  if(qs.get('repo')) $('#ghRepo').value = qs.get('repo');
  if(qs.get('branch')) $('#ghBranch').value = qs.get('branch');
  if(qs.get('path')) $('#ghPath').value = qs.get('path');

  // Initial empty grid
  data = [['ColA','ColB','ColC'],['','','']];
  hasHeader = true;
  fileName = '';
  renderTable();
</script>
</body>
</html>
